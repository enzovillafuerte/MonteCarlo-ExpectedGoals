# Defining a counter to count the number of goals
home_goals <- 0
# Making sure we only execute if there are records (shots) in the dataframe
# Some teams may have done so bad that did not shoot in the entire game. Rare but possible.
if (nrow(home_shots) > 0) {
# For loop to iterate over the shots in the game
for (shot in home_shots$shot_statsbomb_xg) {
# Sampling a random number between 0 and 1
# We use runif following a uniform distribution
prob <- runif(1)
# If the random number is less than the Expected Goals (xG) then it counts as a goal
# Explain and Expand in report the reasoning behind this
if (prob < shot) {
home_goals <- home_goals + 1
}
}
}
# Simulating -- Away Team -- Goals
# Defining a counter for away team
away_goals <- 0
# Repeat the same block of code but for the away counter
if (nrow(away_shots) > 0) {
for (shot in away_shots$shot_statsbomb_xg){
prob <- runif(1)
if (prob < shot) {
away_goals <- away_goals + 1
}
}
}
return(setNames(
list(home_goals, away_goals),
c(home_team, away_team)
))
}
# match_id of the game we are interested
# a = 7532
a = 7546
result <- simulate_game(a)
print(result[[1]] > result[[2]])
print(result$home_team)
# Function simulating a match
#############################################
# ITERATING K TIMES - MONTECARLO EXPECTED GOALS
#############################################
k_simulations <- function(match_id, k=10000){
# Getting the team names section -- Keeping comments out for readability
game_data <- data[data$match_id == match_id,]
teams <- unique(game_data$team)
home_team <- teams[1] # i.e. "Peru"
away_team <- teams[2] # i.e. "Denmark"
# H2H (Head to Head) Ocurrences
home <- 0
draw <- 0
away <- 0
# Over 2.5 Goals Ocurrences
o_2_5 <- 0
u_2_5 <- 0
# Creating the for loop to iterate the previous function k times and store results
for (i in 1:k) {
# Apply the function
simulation <- simulate_game(a)
# If statements to populate the H2H and O2.5 variables based on simulation
if (simulation[[1]] > simulation[[2]]) {
home <- home + 1
if (simulation[[1]] + simulation[[2]] > 2.5) {
o_2_5 <- o_2_5 + 1
}
else {
u_2_5 <- u_2_5 + 1
}
}
else if (simulation[[1]] < simulation[[2]]) {
away <- away + 1
if (simulation[[1]] + simulation[[2]] > 2.5) {
o_2_5 <- o_2_5 + 1
}
else {
u_2_5 <- u_2_5 + 1
}
}
else {
draw <- draw + 1
if (simulation[[1]] + simulation[[2]] > 2.5) {
o_2_5 <- o_2_5 + 1
}
else {
u_2_5 <- u_2_5 + 1
}
}
}
# Calculate probabilities for each outcome
# H2H
home_prob <- home / k
draw_prob <- draw / k
away_prob <- away / k
# O/U
o2_5_prob <- o_2_5 / k
u2_5_prob <- u_2_5 / k
return(setNames(
list(home_prob, draw_prob, away_prob, o2_5_prob, u2_5_prob),
c(home_team, 'Draw', away_team, '+2.5', '-2.5')
))
}
final_montecarlo <- k_simulations(a)
print(final_montecarlo)
#############################################
# GRAPH SECTION FOR REPORT
#############################################
# color pallettes for brewer: https://r-graph-gallery.com/38-rcolorbrewers-palettes.html
# Setting output directory to save the plots for report
output_dir <- 'plots'
# Extracting names and probabilities
team_names <- names(final_montecarlo)
probabilities <- unlist(final_montecarlo)  # Converting into a vector
# Head-to-Head -- Graph 1
df_h2h <- data.frame(
Outcome = team_names[1:3],   # Only getting Home,Draw, and Away
Probability = probabilities[1:3]
)
h2h_plot <- ggplot(df_h2h, aes(x = Outcome, y = Probability, fill = Outcome)) +
geom_bar(stat = "identity") +
ggtitle("Head-to-Head Probabilities") +
xlab("Outcome") +
ylab("Probability") +
scale_y_continuous(limits = c(0, 1)) +
scale_fill_brewer(palette = "PuBu") +
theme_minimal()
# Saving the plot
ggsave(filename= file.path(output_dir, 'h2h_probabilities.png'),
plot = h2h_plot, width = 6, height = 4, dpi =300)
# Over/Under Goals -- Graph 2
df_ou <- data.frame(
Outcome = team_names[4:5],
Probability = probabilities[4:5]
)
ou_plot <- ggplot(df_ou, aes(x = Outcome, y = Probability, fill = Outcome)) +
geom_bar(stat = "identity") +
ggtitle("Over/Under 2.5 Goals Probabilities") +
xlab("Outcome") +
ylab("Probability (%)") +
scale_y_continuous(limits = c(0, 1)) +
scale_fill_brewer(palette = "PuBu") + # PuBu
theme_minimal()
# Saving the plot
ggsave(filename= file.path(output_dir, 'o_u_probabilities.png'),
plot = ou_plot, width = 4, height = 4, dpi = 300)
#############################################
# EXPECTED POINTS SECTION
#############################################
h2h_plot
df_h2h
View(data)
# Import libraries
library(readr)
library(ggplot2)
library(RColorBrewer)
library(viridis)
# Data is being extracted using Statsbomb's Python API
# See data_extraction.py script for more reference
# Read the dataset with the consolidated data
data <- read.csv('WC_Group_C_2018.csv')
# Get a list of the column names
colnames(data)
#############################################
# SIMULATING ONE GAME SECTION
#############################################
# Filtering to keep only the data for the game I need: Peru vs Denmark
# match_id = 7532
simulate_game <- function(match_id) {
# Filtering the game to account only for the game of interest
game_data <- data[data$match_id == match_id,]
# Getting a list of the two teams involved -distinct Python/SQL | unique R
teams <- unique(game_data$team)
# Indexing the list and assigning the values to both home and away_teams
home_team <- teams[1] # i.e. "Peru"
away_team <- teams[2] # i.e. "Denmark"
# Filtering the dataframe to two different dataframes for each team
home_shots <- game_data[game_data$team == home_team,]
away_shots <- game_data[game_data$team == away_team,]
# Simulating -- Home Team -- Goals
# Defining a counter to count the number of goals
home_goals <- 0
# Making sure we only execute if there are records (shots) in the dataframe
# Some teams may have done so bad that did not shoot in the entire game. Rare but possible.
if (nrow(home_shots) > 0) {
# For loop to iterate over the shots in the game
for (shot in home_shots$shot_statsbomb_xg) {
# Sampling a random number between 0 and 1
# We use runif following a uniform distribution
prob <- runif(1)
# If the random number is less than the Expected Goals (xG) then it counts as a goal
# Explain and Expand in report the reasoning behind this
if (prob < shot) {
home_goals <- home_goals + 1
}
}
}
# Simulating -- Away Team -- Goals
# Defining a counter for away team
away_goals <- 0
# Repeat the same block of code but for the away counter
if (nrow(away_shots) > 0) {
for (shot in away_shots$shot_statsbomb_xg){
prob <- runif(1)
if (prob < shot) {
away_goals <- away_goals + 1
}
}
}
return(setNames(
list(home_goals, away_goals),
c(home_team, away_team)
))
}
# match_id of the game we are interested
# a = 7532 # Peru vs Denmark
# a = 7546 # Peru vs France
a = 7562 # Peru vs Australia
result <- simulate_game(a)
print(result[[1]] > result[[2]])
print(result$home_team)
# Function simulating a match
#############################################
# ITERATING K TIMES - MONTECARLO EXPECTED GOALS
#############################################
k_simulations <- function(match_id, k=10000){
# Getting the team names section -- Keeping comments out for readability
game_data <- data[data$match_id == match_id,]
teams <- unique(game_data$team)
home_team <- teams[1] # i.e. "Peru"
away_team <- teams[2] # i.e. "Denmark"
# H2H (Head to Head) Ocurrences
home <- 0
draw <- 0
away <- 0
# Over 2.5 Goals Ocurrences
o_2_5 <- 0
u_2_5 <- 0
# Creating the for loop to iterate the previous function k times and store results
for (i in 1:k) {
# Apply the function
simulation <- simulate_game(a)
# If statements to populate the H2H and O2.5 variables based on simulation
if (simulation[[1]] > simulation[[2]]) {
home <- home + 1
if (simulation[[1]] + simulation[[2]] > 2.5) {
o_2_5 <- o_2_5 + 1
}
else {
u_2_5 <- u_2_5 + 1
}
}
else if (simulation[[1]] < simulation[[2]]) {
away <- away + 1
if (simulation[[1]] + simulation[[2]] > 2.5) {
o_2_5 <- o_2_5 + 1
}
else {
u_2_5 <- u_2_5 + 1
}
}
else {
draw <- draw + 1
if (simulation[[1]] + simulation[[2]] > 2.5) {
o_2_5 <- o_2_5 + 1
}
else {
u_2_5 <- u_2_5 + 1
}
}
}
# Calculate probabilities for each outcome
# H2H
home_prob <- home / k
draw_prob <- draw / k
away_prob <- away / k
# O/U
o2_5_prob <- o_2_5 / k
u2_5_prob <- u_2_5 / k
return(setNames(
list(home_prob, draw_prob, away_prob, o2_5_prob, u2_5_prob),
c(home_team, 'Draw', away_team, '+2.5', '-2.5')
))
}
final_montecarlo <- k_simulations(a)
print(final_montecarlo)
#############################################
# GRAPH SECTION FOR REPORT
#############################################
# color pallettes for brewer: https://r-graph-gallery.com/38-rcolorbrewers-palettes.html
# Setting output directory to save the plots for report
output_dir <- 'plots'
# Extracting names and probabilities
team_names <- names(final_montecarlo)
probabilities <- unlist(final_montecarlo)  # Converting into a vector
# Head-to-Head -- Graph 1
df_h2h <- data.frame(
Outcome = team_names[1:3],   # Only getting Home,Draw, and Away
Probability = probabilities[1:3]
)
h2h_plot <- ggplot(df_h2h, aes(x = Outcome, y = Probability, fill = Outcome)) +
geom_bar(stat = "identity") +
ggtitle("Head-to-Head Probabilities") +
xlab("Outcome") +
ylab("Probability") +
scale_y_continuous(limits = c(0, 1)) +
scale_fill_brewer(palette = "PuBu") +
theme_minimal()
# Saving the plot
ggsave(filename= file.path(output_dir, 'h2h_probabilities.png'),
plot = h2h_plot, width = 6, height = 4, dpi =300)
# Over/Under Goals -- Graph 2
df_ou <- data.frame(
Outcome = team_names[4:5],
Probability = probabilities[4:5]
)
ou_plot <- ggplot(df_ou, aes(x = Outcome, y = Probability, fill = Outcome)) +
geom_bar(stat = "identity") +
ggtitle("Over/Under 2.5 Goals Probabilities") +
xlab("Outcome") +
ylab("Probability (%)") +
scale_y_continuous(limits = c(0, 1)) +
scale_fill_brewer(palette = "PuBu") + # PuBu
theme_minimal()
# Saving the plot
ggsave(filename= file.path(output_dir, 'o_u_probabilities.png'),
plot = ou_plot, width = 4, height = 4, dpi = 300)
#############################################
# EXPECTED POINTS SECTION
#############################################
h2h_plot
df_h2h
# Import libraries
library(readr)
library(ggplot2)
library(RColorBrewer)
library(viridis)
# Data is being extracted using Statsbomb's Python API
# See data_extraction.py script for more reference
# Read the dataset with the consolidated data
data <- read.csv('WC_Group_C_2018.csv')
# Get a list of the column names
colnames(data)
#############################################
# SIMULATING ONE GAME SECTION
#############################################
# Filtering to keep only the data for the game I need: Peru vs Denmark
# match_id = 7532
simulate_game <- function(match_id) {
# Filtering the game to account only for the game of interest
game_data <- data[data$match_id == match_id,]
# Getting a list of the two teams involved -distinct Python/SQL | unique R
teams <- unique(game_data$team)
# Indexing the list and assigning the values to both home and away_teams
home_team <- teams[1] # i.e. "Peru"
away_team <- teams[2] # i.e. "Denmark"
# Filtering the dataframe to two different dataframes for each team
home_shots <- game_data[game_data$team == home_team,]
away_shots <- game_data[game_data$team == away_team,]
# Simulating -- Home Team -- Goals
# Defining a counter to count the number of goals
home_goals <- 0
# Making sure we only execute if there are records (shots) in the dataframe
# Some teams may have done so bad that did not shoot in the entire game. Rare but possible.
if (nrow(home_shots) > 0) {
# For loop to iterate over the shots in the game
for (shot in home_shots$shot_statsbomb_xg) {
# Sampling a random number between 0 and 1
# We use runif following a uniform distribution
prob <- runif(1)
# If the random number is less than the Expected Goals (xG) then it counts as a goal
# Explain and Expand in report the reasoning behind this
if (prob < shot) {
home_goals <- home_goals + 1
}
}
}
# Simulating -- Away Team -- Goals
# Defining a counter for away team
away_goals <- 0
# Repeat the same block of code but for the away counter
if (nrow(away_shots) > 0) {
for (shot in away_shots$shot_statsbomb_xg){
prob <- runif(1)
if (prob < shot) {
away_goals <- away_goals + 1
}
}
}
return(setNames(
list(home_goals, away_goals),
c(home_team, away_team)
))
}
# match_id of the game we are interested
a = 7532 # Peru vs Denmark
# a = 7546 # Peru vs France
# a = 7562 # Peru vs Australia
result <- simulate_game(a)
print(result[[1]] > result[[2]])
print(result$home_team)
# Function simulating a match
#############################################
# ITERATING K TIMES - MONTECARLO EXPECTED GOALS
#############################################
k_simulations <- function(match_id, k=10000){
# Getting the team names section -- Keeping comments out for readability
game_data <- data[data$match_id == match_id,]
teams <- unique(game_data$team)
home_team <- teams[1] # i.e. "Peru"
away_team <- teams[2] # i.e. "Denmark"
# H2H (Head to Head) Ocurrences
home <- 0
draw <- 0
away <- 0
# Over 2.5 Goals Ocurrences
o_2_5 <- 0
u_2_5 <- 0
# Creating the for loop to iterate the previous function k times and store results
for (i in 1:k) {
# Apply the function
simulation <- simulate_game(a)
# If statements to populate the H2H and O2.5 variables based on simulation
if (simulation[[1]] > simulation[[2]]) {
home <- home + 1
if (simulation[[1]] + simulation[[2]] > 2.5) {
o_2_5 <- o_2_5 + 1
}
else {
u_2_5 <- u_2_5 + 1
}
}
else if (simulation[[1]] < simulation[[2]]) {
away <- away + 1
if (simulation[[1]] + simulation[[2]] > 2.5) {
o_2_5 <- o_2_5 + 1
}
else {
u_2_5 <- u_2_5 + 1
}
}
else {
draw <- draw + 1
if (simulation[[1]] + simulation[[2]] > 2.5) {
o_2_5 <- o_2_5 + 1
}
else {
u_2_5 <- u_2_5 + 1
}
}
}
# Calculate probabilities for each outcome
# H2H
home_prob <- home / k
draw_prob <- draw / k
away_prob <- away / k
# O/U
o2_5_prob <- o_2_5 / k
u2_5_prob <- u_2_5 / k
return(setNames(
list(home_prob, draw_prob, away_prob, o2_5_prob, u2_5_prob),
c(home_team, 'Draw', away_team, '+2.5', '-2.5')
))
}
final_montecarlo <- k_simulations(a)
print(final_montecarlo)
#############################################
# GRAPH SECTION FOR REPORT
#############################################
# color pallettes for brewer: https://r-graph-gallery.com/38-rcolorbrewers-palettes.html
# Setting output directory to save the plots for report
output_dir <- 'plots'
# Extracting names and probabilities
team_names <- names(final_montecarlo)
probabilities <- unlist(final_montecarlo)  # Converting into a vector
# Head-to-Head -- Graph 1
df_h2h <- data.frame(
Outcome = team_names[1:3],   # Only getting Home,Draw, and Away
Probability = probabilities[1:3]
)
h2h_plot <- ggplot(df_h2h, aes(x = Outcome, y = Probability, fill = Outcome)) +
geom_bar(stat = "identity") +
ggtitle("Head-to-Head Probabilities") +
xlab("Outcome") +
ylab("Probability") +
scale_y_continuous(limits = c(0, 1)) +
scale_fill_brewer(palette = "PuBu") +
theme_minimal()
# Saving the plot
ggsave(filename= file.path(output_dir, 'h2h_probabilities.png'),
plot = h2h_plot, width = 6, height = 4, dpi =300)
# Over/Under Goals -- Graph 2
df_ou <- data.frame(
Outcome = team_names[4:5],
Probability = probabilities[4:5]
)
ou_plot <- ggplot(df_ou, aes(x = Outcome, y = Probability, fill = Outcome)) +
geom_bar(stat = "identity") +
ggtitle("Over/Under 2.5 Goals Probabilities") +
xlab("Outcome") +
ylab("Probability (%)") +
scale_y_continuous(limits = c(0, 1)) +
scale_fill_brewer(palette = "PuBu") + # PuBu
theme_minimal()
# Saving the plot
ggsave(filename= file.path(output_dir, 'o_u_probabilities.png'),
plot = ou_plot, width = 4, height = 4, dpi = 300)
#############################################
# EXPECTED POINTS SECTION
#############################################
h2h_plot
df_h2h
